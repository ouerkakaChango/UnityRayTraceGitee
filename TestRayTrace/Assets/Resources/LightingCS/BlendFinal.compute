// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BlendFnial
#pragma kernel CopyToNewFront
#pragma kernel TextureAA

#include "../../HLSL/CommonDef.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> Direct;
Texture2D<float4> Indirect;
Texture2D<float4> FrontIndirect;
RWTexture2D<float4> NewFrontIndirect;
int frameID;
float indirectMultiplier;

Texture2D<float3> blueNoise;

[numthreads(8, 8, 1)]
void BlendFnial(uint3 id : SV_DispatchThreadID)
{
	float4 IndirectPart = 0;
	if (frameID == 0)
	{
		IndirectPart = Indirect[id.xy];
	}
	else
	{
		//A(n/(n+1))+B(1/(n+1))
		float n = frameID;
		IndirectPart = n / (n + 1)*FrontIndirect[id.xy] + 1 / (n + 1)*Indirect[id.xy];
		//IndirectPart = FrontIndirect[id.xy] + Indirect[id.xy];
	}
	float4 color = Direct[id.xy] + indirectMultiplier*IndirectPart;

	uint2 size = GetSize(Result);
	float2 uv = id.xy/(float2)size;
	int2 fragCoord = uv * 1024;//blueNoise is 1024*1024
	//color.rgb += blueNoise.Load(int3(fragCoord & 1023, 0)).rgb * (1.0 / 256.0);//For our mornitor only support 32bit 

	Result[id.xy] = color;
	NewFrontIndirect[id.xy] = IndirectPart;
}

[numthreads(8, 8, 1)]
void CopyToNewFront(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = NewFrontIndirect[id.xy];
}

float mfwidth(float x)
{
	return x;
}

float3 texFiltered(Texture2D<float4> inTexture, in float3 rayDir)
{
	//Scale of the texture
	float scale = 1.;
	//This defines the width of the blur kernel 0.5 to 1. seems to work fine.
	float wd = .75 / scale;

	float w = mfwidth(rayDir.y)*wd;
	float d1 = rayDir.y / scale - (w / 2.0);
	float d2 = d1 + w;
	float3 t1 = GetRGB(inTexture, float2(d1, rayDir.z / scale)).rgb;
	float3 t2 = GetRGB(inTexture, float2(d2, rayDir.z / scale)).rgb;
	float3 col = (t1 + t2)*0.5;

	w = mfwidth(rayDir.z)*wd;
	d1 = rayDir.z / scale - (w / 2.0);
	d2 = d1 + w;
	t1 = GetRGB(inTexture, float2(rayDir.y / scale, d1)).rgb;
	t2 = GetRGB(inTexture, float2(rayDir.y / scale, d2)).rgb;
	float3 col2 = (t1 + t2)*0.5;
	col = lerp(col, col2, .5);

	return col;
}

[numthreads(8, 8, 1)]
void TextureAA(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = Direct[id.xy];
}