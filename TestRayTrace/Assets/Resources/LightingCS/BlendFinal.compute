// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BlendIndirect
#pragma kernel CopyToNewFront
#pragma kernel TextureAA
#pragma kernel BlendTAA

#include "../../HLSL/CommonDef.hlsl"

RWTexture2D<float4> Result;
int frameID;

Texture2D<float4> Direct;
Texture2D<float4> Indirect;
Texture2D<float4> FrontIndirect;
RWTexture2D<float4> NewFrontIndirect;
float indirectMultiplier;
Texture2D<float3> blueNoise;
[numthreads(8, 8, 1)]
void BlendIndirect(uint3 id : SV_DispatchThreadID)
{
	float4 IndirectPart = 0;
	if (frameID == 0)
	{
		IndirectPart = Indirect[id.xy];
	}
	else
	{
		//A(n/(n+1))+B(1/(n+1))
		float n = frameID;
		IndirectPart = n / (n + 1)*FrontIndirect[id.xy] + 1 / (n + 1)*Indirect[id.xy];
		//IndirectPart = FrontIndirect[id.xy] + Indirect[id.xy];
	}
	float4 color = Direct[id.xy] + indirectMultiplier*IndirectPart;

	uint2 size = GetSize(Result);
	float2 uv = id.xy/(float2)size;
	int2 fragCoord = uv * 1024;//blueNoise is 1024*1024
	//color.rgb += blueNoise.Load(int3(fragCoord & 1023, 0)).rgb * (1.0 / 256.0);//For our mornitor only support 32bit 

	Result[id.xy] = color;
	NewFrontIndirect[id.xy] = IndirectPart;
}

[numthreads(8, 8, 1)]
void CopyToNewFront(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = NewFrontIndirect[id.xy];
}

float mfwidth(float x)
{
	return x;
}

float3 texFiltered(Texture2D<float4> inTexture, in float3 rayDir)
{
	//Scale of the texture
	float scale = 1.;
	//This defines the width of the blur kernel 0.5 to 1. seems to work fine.
	float wd = .75 / scale;

	float w = mfwidth(rayDir.y)*wd;
	float d1 = rayDir.y / scale - (w / 2.0);
	float d2 = d1 + w;
	float3 t1 = GetRGB(inTexture, float2(d1, rayDir.z / scale)).rgb;
	float3 t2 = GetRGB(inTexture, float2(d2, rayDir.z / scale)).rgb;
	float3 col = (t1 + t2)*0.5;

	w = mfwidth(rayDir.z)*wd;
	d1 = rayDir.z / scale - (w / 2.0);
	d2 = d1 + w;
	t1 = GetRGB(inTexture, float2(rayDir.y / scale, d1)).rgb;
	t2 = GetRGB(inTexture, float2(rayDir.y / scale, d2)).rgb;
	float3 col2 = (t1 + t2)*0.5;
	col = lerp(col, col2, .5);

	return col;
}

[numthreads(8, 8, 1)]
void TextureAA(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = Direct[id.xy];
}
//---TAA-------------------------------------------------------------------------------------------
float pixW;
float pixH;
float3 screenLeftDownPix;
float3 eyePos;
float3 screenU;
float3 screenV;

Texture2D<float4> TexA;
Texture2D<float4> TexB;
Texture2D<float> TexADepth;
float TAAMultiplier;
[numthreads(8, 8, 1)]
void BlendTAA(uint3 id : SV_DispatchThreadID)
{
	//A: rt_beforeTAA
	//B: rt_lastAfterTAA
	if (frameID == 0)
	{
		Result[id.xy] = TexA[id.xy];
		return;
	}
	float3 col1 = TexA[id.xy].rgb;
	float3 re = col1;
	//1.eyeDepth
	float eyeDepth = TexADepth[id.xy].r;
	if (eyeDepth >= 0)
	{
		//2.rayPos,rayDir
		float3 camFoward = normalize(cross(screenU, screenV));
		float3 pixLeftDownPos = screenLeftDownPix + screenU * pixW * (id.x - 0.5) + screenV * pixH * (id.y - 0.5);
		//??? pixelLocalPos: Low Discrepancy Sequence
		float2 pixelLocalPos = float2(0.5, 0.5);
		float3 rayPos = pixLeftDownPos + screenU * pixW * pixelLocalPos.x + screenV * pixH * pixelLocalPos.y;
		float3 rayDir = normalize(rayPos - eyePos);
		//3.worldPos
		float3 p = rayPos + eyeDepth * rayDir;

		float3 col2 = TexB[id.xy].rgb;
		re = col1 * (1 - TAAMultiplier) + col2 * TAAMultiplier;
		re = p;
	}
	Result[id.xy] = float4(re, 1);
}
//___TAA________________________________________________________________________