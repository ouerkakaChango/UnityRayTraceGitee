// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BlendIndirect
#pragma kernel CopyToNewFront
#pragma kernel TextureAA
#pragma kernel BlendTAA

#include "../../HLSL/CommonDef.hlsl"
#include "../../HLSL/RayMath.hlsl"

RWTexture2D<float4> Result;
int frameID;

Texture2D<float4> Direct;
Texture2D<float4> Indirect;
Texture2D<float4> FrontIndirect;
RWTexture2D<float4> NewFrontIndirect;
float indirectMultiplier;
Texture2D<float3> blueNoise;
[numthreads(8, 8, 1)]
void BlendIndirect(uint3 id : SV_DispatchThreadID)
{
	float4 IndirectPart = 0;
	if (frameID == 0)
	{
		IndirectPart = Indirect[id.xy];
	}
	else
	{
		//A(n/(n+1))+B(1/(n+1))
		float n = frameID;
		IndirectPart = n / (n + 1)*FrontIndirect[id.xy] + 1 / (n + 1)*Indirect[id.xy];
		//IndirectPart = FrontIndirect[id.xy] + Indirect[id.xy];
	}
	float4 color = Direct[id.xy] + indirectMultiplier*IndirectPart;

	uint2 size = GetSize(Result);
	float2 uv = id.xy/(float2)size;
	int2 fragCoord = uv * 1024;//blueNoise is 1024*1024
	//color.rgb += blueNoise.Load(int3(fragCoord & 1023, 0)).rgb * (1.0 / 256.0);//For our mornitor only support 32bit 

	Result[id.xy] = color;
	NewFrontIndirect[id.xy] = IndirectPart;
}

[numthreads(8, 8, 1)]
void CopyToNewFront(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = NewFrontIndirect[id.xy];
}

float mfwidth(float x)
{
	return x;
}

float3 texFiltered(Texture2D<float4> inTexture, in float3 rayDir)
{
	//Scale of the texture
	float scale = 1.;
	//This defines the width of the blur kernel 0.5 to 1. seems to work fine.
	float wd = .75 / scale;

	float w = mfwidth(rayDir.y)*wd;
	float d1 = rayDir.y / scale - (w / 2.0);
	float d2 = d1 + w;
	float3 t1 = GetRGB(inTexture, float2(d1, rayDir.z / scale)).rgb;
	float3 t2 = GetRGB(inTexture, float2(d2, rayDir.z / scale)).rgb;
	float3 col = (t1 + t2)*0.5;

	w = mfwidth(rayDir.z)*wd;
	d1 = rayDir.z / scale - (w / 2.0);
	d2 = d1 + w;
	t1 = GetRGB(inTexture, float2(rayDir.y / scale, d1)).rgb;
	t2 = GetRGB(inTexture, float2(rayDir.y / scale, d2)).rgb;
	float3 col2 = (t1 + t2)*0.5;
	col = lerp(col, col2, .5);

	return col;
}

[numthreads(8, 8, 1)]
void TextureAA(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = Direct[id.xy];
}
//---TAA-------------------------------------------------------------------------------------------
#include "../../HLSL/Random/RandUtility.hlsl"

//https://zhuanlan.zhihu.com/p/425233743
float3 TAA_clipedColor(Texture2D<float4> texA, float2 nowUV, float3 nowColor ,float3 HistoryColor)
{
	float3 AABBMin, AABBMax;
	AABBMin = RGBToYCoCg(nowColor);
	AABBMax = AABBMin;
	int2 kOffsets3x3[9] = {
		int2(-1,-1),
		int2(-1,0),
		int2(-1,1),
		int2(0,-1),
		int2(0,0),
		int2(0,1),
		int2(1,-1),
		int2(1,0),
		int2(1,1),
	};
	for(int k=0;k<9;k++)
	{
		float3 neighbourColor = texA.SampleLevel(common_point_clamp_sampler, nowUV, 0, kOffsets3x3[k]).rgb;
		float3 C = RGBToYCoCg(neighbourColor);
		AABBMin = min(AABBMin, C);
		AABBMax = max(AABBMax, C);
	}

	float3 History = RGBToYCoCg(HistoryColor);

	float3 Filtered = (AABBMin + AABBMax) * 0.5f;
	float3 RayOrigin = History;
	float3 RayDir = Filtered - History;
	RayDir = abs(RayDir) < (1.0 / 65536.0) ? (1.0 / 65536.0) : RayDir;
	float3 InvRayDir = rcp(RayDir);

	float3 MinIntersect = (AABBMin - RayOrigin) * InvRayDir;
	float3 MaxIntersect = (AABBMax - RayOrigin) * InvRayDir;
	float3 EnterIntersect = min(MinIntersect, MaxIntersect);
	float ClipBlend = max(EnterIntersect.x, max(EnterIntersect.y, EnterIntersect.z));
	ClipBlend = saturate(ClipBlend);

	float3 ResultYCoCg = lerp(History, Filtered, ClipBlend);

	return YCoCgToRGB(ResultYCoCg);
}

float pixW;
float pixH;
float3 screenLeftDownPix;
float3 eyePos;
float3 screenU;
float3 screenV;

float3 last_screenLeftDownPix;
float3 last_eyePos;
float3 last_screenU;
float3 last_screenV;

Texture2D<float4> TexA;
Texture2D<float4> TexB;
Texture2D<float> TexADepth;
float TAAMultiplier;
[numthreads(8, 8, 1)]
void BlendTAA(uint3 id : SV_DispatchThreadID)
{
	//A: rt_beforeTAA
	//B: rt_lastAfterTAA
	if (frameID == 0)
	{
		Result[id.xy] = TexA[id.xy];
		return;
	}
	float3 col1 = TexA[id.xy].rgb;
	float3 re = col1;
	//1.eyeDepth
	float eyeDepth = TexADepth[id.xy].r;
	if (eyeDepth >= 0)
	{
		//2.rayPos,rayDir
		float3 camFoward = normalize(cross(screenU, screenV));
		float3 pixLeftDownPos = screenLeftDownPix + screenU * pixW * (id.x - 0.5) + screenV * pixH * (id.y - 0.5);
		// pixelLocalPos: Low Discrepancy Sequence
		float3 seed = float3(id.xy, frameID);
		//!!!
		{
			pixLeftDownPos += 0.0001*randP_sphere(seed);
		}
		float2 uv_lds = float2(rand01(seed.zxy), rand01(seed.zyx));
		float2 pixelLocalPos = uv_lds;//sobolVec2(frameID, 0);//float2(0.5, 0.5);
		float3 rayPos = pixLeftDownPos + screenU * pixW * pixelLocalPos.x + screenV * pixH * pixelLocalPos.y;
		float3 rayDir = normalize(rayPos - eyePos);
		//3.worldPos
		float3 p = rayPos + eyeDepth * rayDir;
		//4.Get lastUV from p
		//4.1 rayCast last_eyePos to p
		Ray lastRay;
		lastRay.pos = last_eyePos;
		lastRay.dir = normalize(p - last_eyePos);

		Plane lastPlane;
		lastPlane.p = last_screenLeftDownPix;
		float3 lastCamFoward = normalize(cross(last_screenU, last_screenV));
		lastPlane.n = -lastCamFoward;

		float dis = RayCastPlane(lastRay, lastPlane);
		if (dis > 0)
		{
			float3 lastScreenPos = lastRay.pos + dis * lastRay.dir;
			float3 lastScreenLeftDownPos = screenLeftDownPix - screenU * pixW * 0.5 - screenV * pixH * 0.5;
			float3 screenVec = lastScreenPos - lastScreenLeftDownPos;
			uint2 size = GetSize(Result);
			float screenULength = pixW * size.x;
			float screenVLength = pixH * size.y;
			float2 lastUV = 0;
			lastUV.x = dot(screenVec, screenU) / screenULength;
			lastUV.y = dot(screenVec, screenV) / screenVLength;

			//??? need solve ghost
			
			if (Is01(lastUV))
			{
				float3 col2 = TexB[lastUV*size].rgb;
				float2 nowUV = id.xy / (float2)size;
				col2 = TAA_clipedColor(TexA, nowUV, col1, col2);
				re = col1 * (1 - TAAMultiplier) + col2 * TAAMultiplier;
				//re = float3(, 0);
			}
		}
	}
	Result[id.xy] = float4(re, 1);
}
//___TAA________________________________________________________________________

[numthreads(8, 8, 1)]
void sdBlendTAA(uint3 id : SV_DispatchThreadID)
{
	//A: rt_beforeTAA
	//B: rt_lastAfterTAA
	if (frameID == 0)
	{
		Result[id.xy] = TexA[id.xy];
		return;
	}
	float3 col1 = TexA[id.xy].rgb;
	float3 re = col1;
	//1.eyeDepth
	float eyeDepth = TexADepth[id.xy].r;
	float3 col2 = TexB[id.xy].rgb;
	re = lerp(col1, col2,0.05);
	Result[id.xy] = float4(re, 1);
}